var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"To use the functionality of DimensionalData in your module, dispatch on AbstractDimArray and AbstractDimension.","category":"page"},{"location":"api/#Arrays","page":"API","title":"Arrays","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"AbstractDimArray\r\nDimArray","category":"page"},{"location":"api/#DimensionalData.AbstractDimArray","page":"API","title":"DimensionalData.AbstractDimArray","text":"AbstracDimArray <: AbstractArray\n\nAbstract supertype for all \"dim\" arrays.\n\nThese arrays return a Tuple of Dimension from a dims method, and can be rebuilt using rebuild.\n\nparent must return the source array.\n\nThey should have metadata, name and refdims methods, although these are optional.\n\nA rebuild method for AbstractDimArray must accept data, dims, refdims, name, metadata arguments.\n\nIndexing AbstractDimArray with non-range AbstractArray has undefined effects on the Dimension index. Use forward-ordered arrays only\"\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.DimArray","page":"API","title":"DimensionalData.DimArray","text":"DimArray <: AbstractDimArray\n\nDimArray(data, dims, refdims, name, metadata)\nDimArray(data, dims::Tuple; refdims=(), name=NoName(), metadata=NoMetadata())\n\nThe main concrete subtype of AbstractDimArray.\n\nDimArray maintains and updates its Dimensions through transformations and moves dimensions to reference dimension refdims after reducing operations (like e.g. mean).\n\nArguments\n\ndata: An AbstractArray.\ndims: A Tuple of Dimension\nname: A string name for the array. Shows in plots and tables.\nrefdims: refence dimensions. Usually set programmatically to track past   slices and reductions of dimension for labelling and reconstruction.\nmetadata: Dict or Metadata object, or NoMetadata()\n\nIndexing can be done with all regular indices, or with Dimensions and/or Selectors. \n\nIndexing AbstractDimArray with non-range AbstractArray has undefined effects on the Dimension index. Use forward-ordered arrays only\"\n\nExample:\n\nusing Dates, DimensionalData\n\nti = (Ti(DateTime(2001):Month(1):DateTime(2001,12)),\nx = X(10:10:100))\nA = DimArray(rand(12,10), (ti, x), \"example\")\n\njulia> A[X(Near([12, 35])), Ti(At(DateTime(2001,5)))];\n\njulia> A[Near(DateTime(2001, 5, 4)), Between(20, 50)];\n\n\n\n\n\n","category":"type"},{"location":"api/#Multi-array-datasets","page":"API","title":"Multi-array datasets","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"AbstractDimStack\r\nDimStack","category":"page"},{"location":"api/#DimensionalData.AbstractDimStack","page":"API","title":"DimensionalData.AbstractDimStack","text":"AbstractDimStack\n\nAbstract supertype for dimensional stacks.\n\nThese have multiple layers of data, but share dimensions.\n\nSee DimStack for the concrete implementation. Most methods are defined on the abstract type.\n\nTo extend AbstractDimStack, implement rebuild and rebuild_from_arrays.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.DimStack","page":"API","title":"DimensionalData.DimStack","text":"DimStack <: AbstractDimStack\n\nDimStack(data::AbstractDimArray...)\nDimStack(data::Tuple{Vararg{<:AbstractDimArray}})\nDimStack(data::NamedTuple{Keys,Vararg{<:AbstractDimArray}})\nDimStack(data::NamedTuple, dims::DimTuple; metadata=NoMetadata())\n\nDimStack holds multiple objects sharing some dimensions, in a NamedTuple. Indexing operates as for AbstractDimArray, except it occurs for all data layers of the stack simulataneously. Layer objects can hold values of any type.\n\nDimStack can be constructed from multiple AbstractDimArray or a NamedTuple of AbstractArray and a matching dims Tuple. If AbstractDimArrays have the same name they will be given the name :layer1, substitiuting the layer number for 1.\n\ngetindex with Int or Dimensions or Selectors that resolve to Int will return a NamedTuple of values from each layer in the stack. This has very good performace, and usually takes less time than the sum of indexing each array separately.\n\nIndexing with a Vector or Colon will return another DimStack where all data layers have been sliced.  setindex! must pass a Tuple or NamedTuple maching the layers.\n\nMost Base and Statistics methods that apply to AbstractArray can be used on all layers of the stack simulataneously. The result is a DimStack, or a NamedTuple if methods like mean are used without dims arguments, and return a single non-array value.\n\nExample\n\njulia> using DimensionalData\n\njulia> A = [1.0 2.0 3.0; 4.0 5.0 6.0];\n\njulia> dimz = (X([:a, :b]), Y(10.0:10.0:30.0))\nX Symbol[a, b],\nY 10.0:10.0:30.0\n\njulia> da1 = DimArray(1A, dimz; name=:one);\n\njulia> da2 = DimArray(2A, dimz; name=:two);\n\njulia> da3 = DimArray(3A, dimz; name=:three);\n\njulia> s = DimStack(da1, da2, da3);\n\njulia> s[At(:b), At(10.0)]\n(one = 4.0, two = 8.0, three = 12.0)\n\njulia> s[X(At(:a))] isa DimStack\ntrue\n\n\n\n\n\n","category":"type"},{"location":"api/#Dimension-indices-generator","page":"API","title":"Dimension indices generator","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"DimIndices\r\nDimKeys","category":"page"},{"location":"api/#DimensionalData.DimIndices","page":"API","title":"DimensionalData.DimIndices","text":"DimIndices <: AbstractArray\n\nDimIndices(x)\nDimIndices(dims::Tuple)\nDimIndices(dims::Dimension)\n\nLike CartesianIndices, but for Dimensions. Behaves as an Array of Tuple of Dimension(i) for all combinations of the axis indices of dims.\n\nThis can be used to view/index into arbitrary dimensions over an array, and is especially useful when combined with otherdims, to iterate over the indices of unknown dimension.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.DimKeys","page":"API","title":"DimensionalData.DimKeys","text":"DimKeys <: AbstractArray\n\nDimKeys(x)\nDimKeys(dims::Tuple)\nDimKeys(dims::Dimension)\n\nLike CartesianIndices, but for the key values of Dimensions. Behaves as an Array of Tuple of Dimension(At(keyvalue)) for all combinations of the axis values of dims.\n\n\n\n\n\n","category":"type"},{"location":"api/#Core-types","page":"API","title":"Core types","text":"","category":"section"},{"location":"api/#Dimensions:","page":"API","title":"Dimensions:","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Dimension\r\nDependentDim\r\nIndependentDim\r\nXDim\r\nYDim\r\nZDim\r\nTimeDim\r\nX\r\nY\r\nZ\r\nTi\r\nParametricDimension\r\nDim\r\nCoord\r\nAnonDim\r\n@dim","category":"page"},{"location":"api/#DimensionalData.Dimension","page":"API","title":"DimensionalData.Dimension","text":"Dimension\n\nAbstract supertype of all dimension types.\n\nExample concrete implementations are X, Y, Z, Ti (Time), and the custom [Dim]@ref) dimension.\n\nDimensions label the axes of an AbstractDimArray, or other dimensional objects, and are used to index into the array.\n\nThey may also provide an alternate index to lookup for each array axis. This may be any AbstractVector matching the array axis length, or a Val holding a tuple for compile-time index lookups.\n\nDimensions also have lookup and metadata fields.\n\nlookup gives more details about the dimension, such as that it is Categorical or Sampled as Points or Intervals along some transect. DimensionalData will attempt to guess the lookup from the passed-in index value.\n\nExample:\n\nusing DimensionalData, Dates\n\nx = X(2:2:10)\ny = Y(['a', 'b', 'c'])\nti = Ti(DateTime(2021, 1):Month(1):DateTime(2021, 12))\n\nA = DimArray(zeros(3, 5, 12), (y, x, ti))\n\n# output\n\n3×5×12 DimArray{Float64,3} with dimensions:\n  Y Categorical Char[a, b, c] ForwardOrdered,\n  X Sampled 2:2:10 ForwardOrdered Regular Points,\n  Ti Sampled DateTime(\"2021-01-01T00:00:00\"):Month(1):DateTime(\"2021-12-01T00:00:00\") ForwardOrdered Regular Points\n[:, :, 1]\n 0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0\n[and 11 more slices...]\n\nFor simplicity, the same Dimension types are also used as wrappers in getindex, like:\n\nx = A[X(2), Y(3)]\n\n# output\n\n12-element DimArray{Float64,1} with dimensions:\n  Ti Sampled DateTime(\"2021-01-01T00:00:00\"):Month(1):DateTime(\"2021-12-01T00:00:00\") ForwardOrdered Regular Points\nand reference dimensions:\n  Y Categorical Char[c] ForwardOrdered,\n  X Sampled 4:2:4 ForwardOrdered Regular Points\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n\nA Dimension can also wrap Selector.\n\nx = A[X(Between(3, 4)), Y(At('b'))]\n\n# output\n\n1×12 DimArray{Float64,2} with dimensions:\n  X Sampled 4:2:4 ForwardOrdered Regular Points,\n  Ti Sampled DateTime(\"2021-01-01T00:00:00\"):Month(1):DateTime(\"2021-12-01T00:00:00\") ForwardOrdered Regular Points\nand reference dimensions:\n  Y Categorical Char[b] ForwardOrdered\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n\nDimension objects may have lookup and metadata fields to track additional information about the data and the index, and their relationship.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.DependentDim","page":"API","title":"DimensionalData.DependentDim","text":"DependentDim <: Dimension\n\nAbstract supertype for Dependent dimensions. These will plot on the Y axis.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.IndependentDim","page":"API","title":"DimensionalData.IndependentDim","text":"IndependentDim <: Dimension\n\nAbstract supertype for independent dimensions. Thise will plot on the X axis.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.XDim","page":"API","title":"DimensionalData.XDim","text":"XDim <: IndependentDim\n\nAbstract supertype for all X dimensions.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.YDim","page":"API","title":"DimensionalData.YDim","text":"YDim <: DependentDim\n\nAbstract supertype for all Y dimensions.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.ZDim","page":"API","title":"DimensionalData.ZDim","text":"ZDim <: DependentDim\n\nAbstract supertype for all Z dimensions.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.TimeDim","page":"API","title":"DimensionalData.TimeDim","text":"TimeDim <: IndependentDim\n\nAbstract supertype for all time dimensions.\n\nIn a TimeDime with Interval sampling the locus will automatically be set to Start(). Dates and times generally refer to the start of a month, hour, second etc., not the central point as is more common with spatial data. `\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.X","page":"API","title":"DimensionalData.X","text":"X <: XDim\n\nX(val=:)\n\nX Dimension. X <: XDim <: IndependentDim\n\nExample:\n\nxdim = X(2:2:10)\n# Or\nval = A[X(1)]\n# Or\nmean(A; dims=X)\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Y","page":"API","title":"DimensionalData.Y","text":"Y <: YDim\n\nY(val=:)\n\nY Dimension. Y <: YDim <: DependentDim\n\nExample:\n\nydim = Y(['a', 'b', 'c'])\n# Or\nval = A[Y(1)]\n# Or\nmean(A; dims=Y)\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Z","page":"API","title":"DimensionalData.Z","text":"Z <: ZDim\n\nZ(val=:)\n\nZ Dimension. Z <: ZDim <: Dimension\n\nExample:\n\nzdim = Z(10:10:100)\n# Or\nval = A[Z(1)]\n# Or\nmean(A; dims=Z)\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Ti","page":"API","title":"DimensionalData.Ti","text":"m     Ti <: TimeDim\n\nTi(val=:)\n\nTime Dimension. Ti <: TimeDim <: IndependentDim\n\nTime is already used by Dates, and T is a common type parameter, We use Ti to avoid clashes.\n\nExample:\n\ntimedim = Ti(DateTime(2021, 1):Month(1):DateTime(2021, 12))\n# Or\nval = A[Ti(1)]\n# Or\nmean(A; dims=Ti)\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.ParametricDimension","page":"API","title":"DimensionalData.ParametricDimension","text":"Abstract supertype for Dimensions with user-set type paremeters\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Dim","page":"API","title":"DimensionalData.Dim","text":"Dim{S}(val=:)\n\nA generic dimension. For use when custom dims are required when loading data from a file. Can be used as keyword arguments for indexing.\n\nDimension types take precedence over same named Dim types when indexing with symbols, or e.g. creating Tables.jl keys.\n\nusing DimensionalData\n\ndim = Dim{:custom}(['a', 'b', 'c'])\n\n# output\n\nDim{:custom} Char[a, b, c]\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Coord","page":"API","title":"DimensionalData.Coord","text":"Coord <: Dimension\n\nA coordinate dimension itself holds dimensions.\n\nThis allows combining point data with other dimensions, such as time.\n\nExample\n\njulia> using DimensionalData\n\njulia> dim = Coord([(1.0,1.0,1.0), (1.0,2.0,2.0), (3.0,4.0,4.0), (1.0,3.0,4.0)], (X(), Y(), Z()))\nCoord ::\n  val: Tuple{Float64, Float64, Float64}[(1.0, 1.0, 1.0), (1.0, 2.0, 2.0), (3.0, 4.0, 4.0), (1.0, 3.0,\n4.0)]\n  lookup: CoordLookup\nCoord{Vector{Tuple{Float64, Float64, Float64}}, DimensionalData.CoordLookup{Tuple{X{Colon, AutoLookup{Auto\nOrder}, NoMetadata}, Y{Colon, AutoLookup{AutoOrder}, NoMetadata}, Z{Colon, AutoLookup{AutoOrder}, NoMetada\nta}}}, NoMetadata}\n\njulia> da = DimArray(0.1:0.1:0.4, dim)\n4-element DimArray{Float64,1} with dimensions:\n  Coord (): Tuple{Float64, Float64, Float64}[(1.0, 1.0, 1.0), (1.0, 2.0, 2.0), (3.0, 4.0, 4.0), (1.0,\n3.0, 4.0)]\n    CoordLookup\n 0.1\n 0.2\n 0.3\n 0.4\n\njulia> da[Coord(Z(At(1.0)), Y(Between(1, 3)))]\n1-element DimArray{Float64,1} with dimensions:\n  Coord (): Tuple{Float64, Float64, Float64}[(1.0, 1.0, 1.0)] CoordLookup\n 0.1\n\njulia> da[Coord(4)] == 0.4\ntrue\n\njulia> da[Coord(Between(1, 5), :, At(4.0))]\n2-element DimArray{Float64,1} with dimensions:\n  Coord (): Tuple{Float64, Float64, Float64}[(3.0, 4.0, 4.0), (1.0, 3.0, 4.0)] CoordLookup\n 0.3\n 0.4\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.AnonDim","page":"API","title":"DimensionalData.AnonDim","text":"AnonDim <: Dimension\n\nAnonDim()\n\nAnonymous dimension. Used when extra dimensions are created, such as during transpose of a vector.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.@dim","page":"API","title":"DimensionalData.@dim","text":"@dim typ [supertype=Dimension] [name::String=string(typ)]\n\nMacro to easily define new dimensions. The supertype will be inserted into the type of the dim. The default is simply YourDim <: Dimension. Making a Dimesion inherit from XDim, YDim, ZDim or TimeDim will affect automatic plot layout and other methods that dispatch on these types. <: YDim are plotted on the Y axis, <: XDim on the X axis, etc.\n\nExample:\n\n@dim Lat YDim \"latitude\"\n@dim Lon XDim \"Longitude\"\n\n\n\n\n\n","category":"macro"},{"location":"api/#Selectors","page":"API","title":"Selectors","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Selector\r\nAt\r\nNear\r\nBetween\r\nContains\r\nWhere","category":"page"},{"location":"api/#DimensionalData.Selector","page":"API","title":"DimensionalData.Selector","text":"Selector\n\nAbstract supertype for all selectors.\n\nSelectors are wrappers that indicate that passed values are not the array indices, but values to be selected from the dimension index, such as DateTime objects for a Ti dimension.\n\nSelectors provided in DimensionalData are:\n\nAt\nBetween\nNear\nWhere\nContains\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.At","page":"API","title":"DimensionalData.At","text":"At <: Selector\n\nAt(x, atol, rtol)\nAt(x; atol=nothing, rtol=nothing)\n\nSelector that exactly matches the value on the passed-in dimensions, or throws an error. For ranges and arrays, every intermediate value must match an existing value - not just the end points.\n\nx can be any value or Vector of values.\n\natol and rtol are passed to isapprox. For Number rtol will be set to Base.rtoldefault, otherwise nothing, and wont be used.\n\nExample\n\nusing DimensionalData\n\nA = DimArray([1 2 3; 4 5 6], (X(10:10:20), Y(5:7)))\nA[X(At(20)), Y(At(6))]\n\n# output\n\n5\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Near","page":"API","title":"DimensionalData.Near","text":"Near <: Selector\n\nNear(x)\n\nSelector that selects the nearest index to x.\n\nWith Points this is simply the index values nearest to the x, however with Intervals it is the interval center nearest to x. This will be offset from the index value for Start and End loci.\n\nExample\n\nusing DimensionalData\n\nA = DimArray([1 2 3; 4 5 6], (X(10:10:20), Y(5:7)))\nA[X(Near(23)), Y(Near(5.1))]\n\n# output\n4\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Between","page":"API","title":"DimensionalData.Between","text":"Between <: Selector\n\nBetween(a, b)\n\nSelector that retreive all indices located between 2 values, evaluated with >= for the lower value, and < for the upper value. This means the same value will not be counted twice in 2 adjacent  Between selections.\n\nFor Intervals the whole interval must be lie between the values. For Points the points must fall between the values. Different Sampling types may give different results with the same input - this is the intended behaviour.\n\nBetween for Irregular intervals is a little complicated. The interval is the distance between a value and the next (for Start locus) or previous (for End locus) value.\n\nFor Center, we take the mid point between two index values as the start and end of each interval. This may or may not make sense for the values in your indes, so use Between with Irregular Intervals(Center()) with caution.\n\nExample\n\nusing DimensionalData\n\nA = DimArray([1 2 3; 4 5 6], (X(10:10:20), Y(5:7)))\nA[X(Between(15, 25)), Y(Between(4, 6.5))]\n\n# output\n\n1×2 DimArray{Int64,2} with dimensions:\n  X Sampled 20:10:20 ForwardOrdered Regular Points,\n  Y Sampled 5:6 ForwardOrdered Regular Points\n 4  5\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Contains","page":"API","title":"DimensionalData.Contains","text":"Contains <: Selector\n\nContains(x)\n\nSelector that selects the interval the value is contained by. If the interval is not present in the index, an error will be thrown.\n\nCan only be used for Intervals or Categorical.\n\nExample\n\nusing DimensionalData\ndims_ = X(10:10:20; sampling=Intervals(Center())),\n        Y(5:7; sampling=Intervals(Center()))\nA = DimArray([1 2 3; 4 5 6], dims_)\nA[X(Contains(8)), Y(Contains(6.8))]\n\n# output\n3\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Where","page":"API","title":"DimensionalData.Where","text":"Where <: Selector\n\nWhere(f::Function)\n\nSelector that filters a dimension lookup by any function that accepts a single value and returns a Bool.\n\nExample\n\nusing DimensionalData\n\nA = DimArray([1 2 3; 4 5 6], (X(10:10:20), Y(19:21)))\nA[X(Where(x -> x > 15)), Y(Where(x -> x in (19, 21)))]\n\n# output\n\n1×2 DimArray{Int64,2} with dimensions:\n  X Sampled Int64[20] ForwardOrdered Regular Points,\n  Y Sampled Int64[19, 21] ForwardOrdered Regular Points\n 4  6\n\n\n\n\n\n","category":"type"},{"location":"api/#Name","page":"API","title":"Name","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"DimensionalData.AbstractName\r\nName\r\nNoName","category":"page"},{"location":"api/#DimensionalData.AbstractName","page":"API","title":"DimensionalData.AbstractName","text":"AbstractName\n\nAbstract supertype for name wrappers.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Name","page":"API","title":"DimensionalData.Name","text":"Name <: AbstractName\n\nName(name::Union{Symbol,Name) => Name\nName(name::NoName) => NoName\n\nName wrapper. This lets arrays keep symbol names when the array wrapp neeeds to be `isbits, like for use on GPUs. It makes the name a property of the type. It's not necessary to use in normal use, a symbol is probably easier.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.NoName","page":"API","title":"DimensionalData.NoName","text":"NoName <: AbstractName\n\nNoName()\n\nNoName specifies an array is not named, and is the default name value for all DimArrays. It can be used in set to remove the array name:\n\nA = set(A, NoName())\n\n\n\n\n\n","category":"type"},{"location":"api/#Metadata","page":"API","title":"Metadata","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"AbstractMetadata\r\nMetadata\r\nNoMetadata","category":"page"},{"location":"api/#DimensionalData.AbstractMetadata","page":"API","title":"DimensionalData.AbstractMetadata","text":"AbstractMetadata{X,T}\n\nAbstract supertype for all metadata wrappers.\n\nMetadata wrappers allow tracking the contents and origin of metadata. This can  facilitate conversion between metadata types (for saving a file to a differenet format) or simply saving data back to the same file type with identical metadata.\n\nUsing a wrapper instead of Dict or NamedTuple also lets us pass metadata  objects to set without ambiguity about where to put them.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Metadata","page":"API","title":"DimensionalData.Metadata","text":"Metadata <: AbstractMetadata\n\nMetadata{X}(val::Union{Dict,NamedTuple})\nMetadata{X}(pairs::Pair...) => Metadata{Dict}\nMetadata{X}(; kw...) => Metadata{NamedTuple}\n\nGeneral Metadata object. The X type parameter categorises the metadata for method dispatch, if required. \n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.NoMetadata","page":"API","title":"DimensionalData.NoMetadata","text":"NoMetadata <: AbstractMetadata\n\nNoMetadata()\n\nIndicates an object has no metadata. Can be used in set to remove any existing metadata.\n\n\n\n\n\n","category":"type"},{"location":"api/#Lookups","page":"API","title":"Lookups","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Lookup\r\nAligned\r\nAbstractSampled\r\nSampled\r\nAbstractCategorical\r\nCategorical\r\nUnaligned\r\nTransformed\r\nNoLookup\r\nAutoLookup\r\nDimensionalData.AutoIndex","category":"page"},{"location":"api/#DimensionalData.Lookup","page":"API","title":"DimensionalData.Lookup","text":"Lookup\n\nTypes defining the behaviour of a lookup index, how it is plotted and how Selectors like Between work.\n\nA Lookup may be a simple type like NoLookup indicating that the index is just the underlying array axis. It could also be a Categorical index indicating the index is ordered or unordered categories, or a Sampled index indicating sampling.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Aligned","page":"API","title":"DimensionalData.Aligned","text":"Aligned <: Lookup\n\nAbstract supertype for Lookups where the index is aligned with the array axes.\n\nThis is by far the most common supertype for Lookup.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.AbstractSampled","page":"API","title":"DimensionalData.AbstractSampled","text":"AbstractSampled <: Aligned\n\nAbstract supertype for Lookups where the index is aligned with the array, and is independent of other dimensions. Sampled is provided by this package, Projected in GeoData.jl also extends AbstractSampled, adding crs projections.\n\nAbstractSampled must have  order, span and sampling fields, or a rebuild method that accpts them as keyword arguments.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Sampled","page":"API","title":"DimensionalData.Sampled","text":"Sampled <: AbstractSampled\n\nSampled(data::AbstractVector, order::Order, span::Span, sampling::Sampling, metadata)\nSampled(; data=AutoIndex(), order=AutoOrder(), span=AutoSpan(), sampling=Points(), metadata=NoMetadata())\n\nA concrete implementation of the Lookup AbstractSampled. It can be used to represent Points or Intervals.\n\nSampled is capable of representing gridded data from a wide range of sources, allowing correct bounds and Selectors for points or intervals of regular, irregular, forward and reverse indexes.\n\nOn AbstractDimArray construction, Sampled lookup is assigned for all lookups of  AbstractRange not assigned to Categorical.\n\nArguments\n\ndata: An AbstractVector of index values, matching the length of the curresponding   array axis. \norder: Order) indicating the order of the index, AutoOrder by   default, detected from the order of data to be ForwardOrdered, ReverseOrdered   or Unordered. Can be provided if this is known and performance is important.\nspan: indicates the size of intervals or distance between points, and will be set to   Regular for AbstractRange and Irregular for AbstractArray,   unless assigned manually.\nsampling: is assigned to Points, unless set to Intervals manually.    Using Intervals will change the behaviour of bounds and Selectorss   to take account for the full size of the interval, rather than the point alone.\nmetadata: a Dict or Metadata wrapper that holds any metadata object adding more   information about the array axis - useful for extending DimensionalData for specific   contexts, like geospatial data in GeoData.jl. By default it is NoMetadata().\n\nExample\n\nCreate an array with [Interval] sampling, and Regular span for a vector with known spacing.\n\nWe set the Locus of the Intervals to Start specifying that the index  values are for the point at the start of the interval.\n\nusing DimensionalData\n\nx = X(Sampled(100:-10:10; sampling=Intervals(Start()))),\ny = Y(Sampled([1, 4, 7, 10]; span=Regular(3), sampling=Intervals(Start())))\nA = rand(x, y)\nlookup(A)\n\n# output\nERROR: syntax: \"Sampled(100:-10:10,; sampling = Intervals(Start()))\" is not a valid function argument name\nStacktrace:\n [1] top-level scope\n   @ none:1\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.AbstractCategorical","page":"API","title":"DimensionalData.AbstractCategorical","text":"AbstractCategorical <: Aligned\n\nLookups where the values are categories.\n\nCategorical is the provided concrete implementation.  but this can easily be extended - all methods are defined for AbstractCategorical.\n\nAll AbstractCategorical must provide a rebuild method with data, order and metadata keyword arguments.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Categorical","page":"API","title":"DimensionalData.Categorical","text":"Categorical <: AbstractCategorical\n\nCategorical(o::Order)\nCategorical(; order=Unordered())\n\nAn Lookup where the values are categories.\n\nThis will be automatically assigned if the index contains AbstractString, Symbol or Char. Otherwise it can be assigned manually.\n\nOrder will not be determined automatically for Categorical, it instead defaults to [Unordered].\n\nArguments\n\ndata: An AbstractVector of index values, matching the length of the curresponding   array axis. \norder: Order) indicating the order of the index, AutoOrder by   default, detected from the order of data to be ForwardOrdered, ReverseOrdered   or Unordered. Can be provided if this is known and performance is important.\nmetadata: a Dict or Metadata wrapper that holds any metadata object adding more   information about the array axis - useful for extending DimensionalData for specific   contexts, like geospatial data in GeoData.jl. By default it is NoMetadata().\n\nExample\n\nCreate an array with [Interval] sampling.\n\nusing DimensionalData\n\nds = X([\"one\", \"two\", \"three\"]), Y([:a, :b, :c, :d])\nA = DimArray(rand(3, 4), ds)\nlookup(A)\n\n# output\n\nCategorical String[one, two, three] Unordered,\nCategorical Symbol[a, b, c, d] ForwardOrdered\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Unaligned","page":"API","title":"DimensionalData.Unaligned","text":"Unaligned <: Lookup\n\nAbstract supertype for Lookup where the index is not aligned to the grid.\n\nIndexing an Unaligned with Selectors must provide all other Unaligned dimensions.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Transformed","page":"API","title":"DimensionalData.Transformed","text":"Transformed <: Unaligned\n\nTransformed(f, dim::Dimension; metadata=NoMetadata())\n\nLookup that uses an affine transformation to convert dimensions from dims(lookup) to dims(array). This can be useful when the dimensions are e.g. rotated from a more commonly used axis.\n\nAny function can be used to do the transformation, but transformations from CoordinateTransformations.jl may be useful.\n\nArguments\n\nf: transformation function\ndims: a tuple containing dimenension types or symbols matching the   order needed by the transform function.\n\nKeyword Arguments\n\nmetdata: \n\nExample\n\nusing DimensionalData, CoordinateTransformations\n\nm = LinearMap([0.5 0.0; 0.0 0.5])\nA = [1 2  3  4\n     5 6  7  8\n     9 10 11 12];\nda = DimArray(A, (t1=Transformed(m, X), t2=Transformed(m, Y)))\n\nda[X(At(6)), Y(At(2))]\n\n# output\n9\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.NoLookup","page":"API","title":"DimensionalData.NoLookup","text":"NoLookup <: Lookup\n\nNoLookup()\n\nA Lookup that is identical to the array axis.  Selectors can't be used on this lookup.\n\nExample\n\nDefining a DimArray without passing an index to the dimensions, it will be assigned NoLookup:\n\nusing DimensionalData\n\nA = DimArray(rand(3, 3), (X, Y))\nlookup(A)\n\n# output\n\nNoLookup, NoLookup\n\nWhich is identical to:\n\nA = DimArray(rand(3, 3), (X(NoLookup()), Y(NoLookup())))\nlookup(A)\n\n# output\n\nNoLookup, NoLookup\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.AutoLookup","page":"API","title":"DimensionalData.AutoLookup","text":"AutoLookup <: Lookup\n\nAutoLookup()\nAutoLookup(index=AutoIndex(); kw...)\n\nAutomatic Lookup, the default lookup. It will be converted automatically to another Lookup when it is possible to detect it from the index.\n\nKeywords will be used in the detected Lookup constructor.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.AutoIndex","page":"API","title":"DimensionalData.AutoIndex","text":"AutoIndex\n\nDetect a Lookup index from the context. This is used in NoLookup to simply use the array axis as the index when the array is constructed, and in set to change the Lookup type without changing the index values.\n\n\n\n\n\n","category":"type"},{"location":"api/#Lookup-traits","page":"API","title":"Lookup traits","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"DimensionalData.LookupTrait","category":"page"},{"location":"api/#DimensionalData.LookupTrait","page":"API","title":"DimensionalData.LookupTrait","text":"LookupTrait\n\nAbstract supertype of all traits of a Lookup.\n\nThese modify the behaviour of the lookup index.\n\n\n\n\n\n","category":"type"},{"location":"api/#Order","page":"API","title":"Order","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Order\r\nUnordered\r\nOrdered\r\nAutoOrder\r\nDimensionalData.ForwardOrdered\r\nDimensionalData.ReverseOrdered","category":"page"},{"location":"api/#DimensionalData.Order","page":"API","title":"DimensionalData.Order","text":"Order <: LookupTrait\n\nTraits for the order of a Lookup. These determine how searchsorted finds values in the index, and how objects are plotted.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Unordered","page":"API","title":"DimensionalData.Unordered","text":"Unordered <: Order\n\nUnordered()\n\nTrait indicating that the array or lookup has no order. This means the index cannot be searched with searchsortedfirst, or similar methods, and that plotting order does not matter.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Ordered","page":"API","title":"DimensionalData.Ordered","text":"Ordered <: Order\n\nSupertype for the order of an ordered Lookup, like ForwardOrdered and ReverseOrdered.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.AutoOrder","page":"API","title":"DimensionalData.AutoOrder","text":"AutoOrder <: Order\n\nAutoOrder()\n\nSpecifies that the Order of a Lookup will be found automatically where possible.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.ForwardOrdered","page":"API","title":"DimensionalData.ForwardOrdered","text":"ForwardOrdered <: Ordered\n\nForwardOrdered()\n\nIndicates that the Lookup index is in the normal forward order.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.ReverseOrdered","page":"API","title":"DimensionalData.ReverseOrdered","text":"ReverseOrdered <: Ordered\n\nReverseOrdered()\n\nIndicates that the Lookup index is in the reverse order.\n\n\n\n\n\n","category":"type"},{"location":"api/#Span","page":"API","title":"Span","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Span\r\nRegular\r\nIrregular\r\nExplicit\r\nAutoSpan","category":"page"},{"location":"api/#DimensionalData.Span","page":"API","title":"DimensionalData.Span","text":"Span <: LookupTrait\n\nDefines the type of span used in a Sampling index. These are Regular or Irregular.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Regular","page":"API","title":"DimensionalData.Regular","text":"Regular <: Span\n\nRegular(step=AutoStep())\n\nPoints or Intervals that have a fixed, regular step.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Irregular","page":"API","title":"DimensionalData.Irregular","text":"Irregular <: Span\n\nIrregular(bounds::Tuple)\nIrregular(lowerbound, upperbound)\n\nPoints or Intervals that have an Irrigular step size. To enable bounds tracking and accuract selectors, the starting bounds are provided as a 2 tuple, or 2 arguments. (nothing, nothing) is acceptable input, the bounds will be guessed from the index, but may be innaccurate.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Explicit","page":"API","title":"DimensionalData.Explicit","text":"Explicit(bounds::AbstractMatix)\n\nIntervals where the span is explicitly listed for every interval.\n\nThis uses a matrix where with length 2 columns for each index value, holding the lower and upper bounds for that specific index.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.AutoSpan","page":"API","title":"DimensionalData.AutoSpan","text":"AutoSpan <: Span\n\nAutoSpan()\n\nSpan will be guessed and replaced by a constructor using format, or by set.\n\n\n\n\n\n","category":"type"},{"location":"api/#Sampling","page":"API","title":"Sampling","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Sampling\r\nPoints\r\nIntervals","category":"page"},{"location":"api/#DimensionalData.Sampling","page":"API","title":"DimensionalData.Sampling","text":"Sampling <: LookupTrait\n\nIndicates the sampling method used by the index: Points or Intervals.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Points","page":"API","title":"DimensionalData.Points","text":"Points <: Sampling\n\nPoints()\n\nSampling lookup where single samples at exact points.\n\nThese are always plotted at the center of array cells.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Intervals","page":"API","title":"DimensionalData.Intervals","text":"Intervals <: Sampling\n\nIntervals(locus::Locus)\n\nSampling specifying that sampled values are the mean (or similar) value over an interval, rather than at one specific point.\n\nIntervals require a Locus of Start, Center or End to define the location in the interval that the index values refer to.\n\n\n\n\n\n","category":"type"},{"location":"api/#Loci","page":"API","title":"Loci","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Locus\r\nCenter\r\nStart\r\nEnd\r\nAutoLocus","category":"page"},{"location":"api/#DimensionalData.Locus","page":"API","title":"DimensionalData.Locus","text":"Locus <: LookupTrait\n\nAbstract supertype of types that indicate the position of index values in cells.\n\nThese allow for values array cells to align with the Start, Center, or End of values in the lookup index.\n\nThis means they can be plotted with correct axis markers, and allows automatic converrsions to between formats with different standards (such as NetCDF and GeoTiff).\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Center","page":"API","title":"DimensionalData.Center","text":"Center <: Locus\n\nCenter()\n\nIndicates a lookup value is for the center of its corresponding array cell, in the direction of the lookup index order.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Start","page":"API","title":"DimensionalData.Start","text":"Start <: Locus\n\nStart()\n\nIndicates a lookup value is for the start of its corresponding array cell, in the direction of the lookup index order.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.End","page":"API","title":"DimensionalData.End","text":"End <: Locus\n\nEnd()\n\nIndicates a lookup value is for the end of its corresponding array cell, in the direction of the lookup index order.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.AutoLocus","page":"API","title":"DimensionalData.AutoLocus","text":"AutoLocus <: Locus\n\nAutoLocus()\n\nIndicates a lookup where the index position is not yet known. This will be filled with a default on object construction.\n\n\n\n\n\n","category":"type"},{"location":"api/#Tables.jl-interface","page":"API","title":"Tables.jl interface","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"DimensionalData.AbstractDimTable\r\nDimTable\r\nDimensionalData.DimColumn","category":"page"},{"location":"api/#DimensionalData.AbstractDimTable","page":"API","title":"DimensionalData.AbstractDimTable","text":"AbstractDimTable <: Tables.AbstractColumns\n\nAbstract supertype for dim tables\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.DimTable","page":"API","title":"DimensionalData.DimTable","text":"DimTable <: AbstractDimTable\n\nDimTable(A::AbstractDimArray)\n\nConstruct a Tables.jl compatible object out of an AbstractDimArray.\n\nThis table will have a column for the array data and columns for each Dimension index, as a [DimColumn]. These are lazy, and generated as required.\n\nColumn names are converted from the dimension types using DimensionalData.dim2key. This means type Ti becomes the column name :Ti, and Dim{:custom} becomes :custom.\n\nTo get dimension columns, you can index with Dimension (X()) or Dimension type (X) as well as the regular Int or Symbol.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.DimColumn","page":"API","title":"DimensionalData.DimColumn","text":"DimColumn{T,D<:Dimension} <: AbstractVector{T}\n\nDimColumn(dim::Dimension, dims::Tuple{Vararg{<:DimTuple}})\nDimColumn(dim::DimColumn, length::Int, dimstride::Int)\n\nA table column based on a Dimension and it's relationship with other Dimensions in dims.\n\nlength is the product of all dim lengths (usually the length of the corresponding array data), while stride is the product of the preceding dimension lengths, which may or may not be the real stride of the corresponding array depending on the data type. For A isa Array, the dimstride will match the stride.\n\nWhen the second argument is a Tuple of Dimension, the length and dimstride fields are calculated from the dimensions, relative to the column dimension dim.\n\nThis object will be returned as a column of DimTable.\n\n\n\n\n\n","category":"type"},{"location":"api/#Methods","page":"API","title":"Methods","text":"","category":"section"},{"location":"api/#Getting-basic-info","page":"API","title":"Getting basic info","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"These useful functions for obtaining information from your dimensional data:","category":"page"},{"location":"api/","page":"API","title":"API","text":"dims\r\nrefdims\r\nmetadata\r\nname\r\nunits\r\nlabel","category":"page"},{"location":"api/#DimensionalData.dims","page":"API","title":"DimensionalData.dims","text":"dims(x, [dims::Tuple]) => Tuple{Vararg{<:Dimension}}\ndims(x, dim) => Dimension\n\nReturn a tuple of Dimensions for an object, in the order that matches the axes or columns of the underlying data.\n\ndims can be Dimension, Dimension types, or Symbols for Dim{Symbol}.\n\nThe default is to return nothing.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.refdims","page":"API","title":"DimensionalData.refdims","text":"refdims(x, [dims::Tuple]) => Tuple{Vararg{<:Dimension}}\nrefdims(x, dim) => Dimension\n\nReference dimensions for an array that is a slice or view of another array with more dimensions.\n\nslicedims(a, dims) returns a tuple containing the current new dimensions and the new reference dimensions. Refdims can be stored in a field or disgarded, as it is mostly to give context to plots. Ignoring refdims will simply leave some captions empty.\n\nThe default is to return an empty Tuple ().\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.metadata","page":"API","title":"DimensionalData.metadata","text":"metadata(x) => (object metadata)\nmetadata(x, dims::Tuple)  => Tuple (Dimension metadata)\nmetadata(xs::Tuple) => Tuple\n\nReturns the metadata for an object or for the specified dimension(s)\n\nSecond argument dims can be Dimensions, Dimension types, or Symbols for Dim{Symbol}.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.name","page":"API","title":"DimensionalData.name","text":"name(x) => String\nname(xs:Tuple) => NTuple{N,String}\nname(x, dims::Tuple) => NTuple{N,String}\nname(x, dim) => String\n\nGet the name of an array or Dimension, or a tuple of of either.\n\nSecond argument dims can be Dimensions, Dimension types, or Symbols for Dim{Symbol}.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.units","page":"API","title":"DimensionalData.units","text":"units(x) => Union{Nothing,Any}\nunits(xs:Tuple) => Tuple\nunit(A::AbstractDimArray, dims::Tuple) => Tuple\nunit(A::AbstractDimArray, dim) => Union{Nothing,Any}\n\nGet the units of an array or Dimension, or a tuple of of either.\n\nUnits do not have a set field, and may or may not be included in metadata. This method is to facilitate use in labels and plots when units are available, not a guarantee that they will be. If not available, nothing is returned.\n\nSecond argument dims can be Dimensions, Dimension types, or Symbols for Dim{Symbol}.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.label","page":"API","title":"DimensionalData.label","text":"label(x) => String\nlabel(x, dims::Tuple) => NTuple{N,String}\nlabel(x, dim) => String\nlabel(xs::Tuple) => NTuple{N,String}\n\nGet a plot label for data or a dimension. This will include the name and units if they exist, and anything else that should be shown on a plot.\n\nSecond argument dims can be Dimensions, Dimension types, or Symbols for Dim{Symbol}.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"Dimesion and lookup properties:","category":"page"},{"location":"api/","page":"API","title":"API","text":"val\r\nindex\r\nlookup\r\nbounds\r\nsampling\r\nlocus\r\nspan\r\norder","category":"page"},{"location":"api/#DimensionalData.val","page":"API","title":"DimensionalData.val","text":"val(x)\nval(dims::Tuple) => Tuple\n\nReturn the contained value of a wrapper object.\n\ndims can be Dimension, Dimension types, or Symbols for Dim{Symbol}.\n\nObjects that don't define a val method are returned unaltered.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.index","page":"API","title":"DimensionalData.index","text":"index(x) => Tuple{Vararg{<:AbstractArray}}\nindex(x, dims::Tuple) => Tuple{Vararg{<:AbstractArray}}\nindex(dims::Tuple) => Tuple{Vararg{<:AbstractArray}}}\nindex(x, dim) => AbstractArray\nindex(dim::Dimension) => AbstractArray\n\nReturn the contained index of a Dimension.\n\nOnly valid when a Dimension contains an AbstractArray or a Val tuple like Val{(:a, :b)}(). The Val is unwrapped to return just the Tuple\n\ndims can be a Dimension, or a tuple of Dimension.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.lookup","page":"API","title":"DimensionalData.lookup","text":"lookup(x::Dimension) => Lookup\nlookup(x, [dims::Tuple]) => Tuple{Vararg{<:Lookup}}\nlookup(x::Tuple) => Tuple{Vararg{<:Lookup}}\nlookup(x, dim) => Lookup\n\nReturns the Lookup of a dimension. This dictates properties of the dimension such as array axis and index order, and sampling properties.\n\ndims can be a Dimension, a dimension type, or a tuple of either.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.bounds","page":"API","title":"DimensionalData.bounds","text":"bounds(xs, [dims::Tuple]) => Tuple{Vararg{<:Tuple{T,T}}}\nbounds(xs::Tuple) => Tuple{Vararg{<:Tuple{T,T}}}\nbounds(x, dim) => Tuple{T,T}\nbounds(dim::Union{Dimension,Lookup}) => Tuple{T,T}\n\nReturn the bounds of all dimensions of an object, of a specific dimension, or of a tuple of dimensions.\n\ndims can be a Dimension, a dimension type, or a tuple of either.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.sampling","page":"API","title":"DimensionalData.sampling","text":"sampling(x, [dims::Tuple]) => Tuple\nsampling(x, dim) => Sampling\nsampling(xs::Tuple) => Tuple{Vararg{<:Sampling}}\nsampling(x:Union{Dimension,Lookup}) => Sampling\n\nReturn the Sampling for each dimension.\n\nSecond argument dims can be Dimensions, Dimension types, or Symbols for Dim{Symbol}.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.locus","page":"API","title":"DimensionalData.locus","text":"locus(x, [dims::Tuple]) => Tuple\nlocus(x, dim) => Locus\nlocus(xs::Tuple) => Tuple{Vararg{<:Locus,N}}\nlocus(x::Union{Dimension,Lookup}) => Locus\n\nReturn the Locus for each dimension.\n\nSecond argument dims can be Dimensions, Dimension types, or Symbols for Dim{Symbol}.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.span","page":"API","title":"DimensionalData.span","text":"span(x, [dims::Tuple]) => Tuple\nspan(x, dim) => Span\nspan(xs::Tuple) => Tuple{Vararg{<:Span,N}}\nspan(x::Union{Dimension,Lookup}) => Span\n\nReturn the Span for each dimension.\n\nSecond argument dims can be Dimensions, Dimension types, or Symbols for Dim{Symbol}.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.order","page":"API","title":"DimensionalData.order","text":"order(x, [dims::Tuple]) => Tuple\norder(xs::Tuple) => Tuple\norder(x::Union{Dimension,Lookup}) => Order\n\nReturn the Ordering of the dimension index for each dimension: ForwardOrdered, ReverseOrdered, or Unordered \n\nSecond argument dims can be Dimensions, Dimension types, or Symbols for Dim{Symbol}.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"Dimension querying","category":"page"},{"location":"api/","page":"API","title":"API","text":"hasdim\r\nhasselection\r\ndimnum\r\notherdims\r\ncommondims","category":"page"},{"location":"api/#DimensionalData.hasdim","page":"API","title":"DimensionalData.hasdim","text":"hasdim([f], x, lookup::Tuple) => NTUple{Bool}\nhasdim([f], x, lookups...) => NTUple{Bool}\nhasdim([f], x, lookup) => Bool\n\nCheck if an object x has dimensions that match or inherit from the lookup dimensions.\n\nArguments\n\nx: any object with a dims method, a Tuple of Dimension or a single Dimension.\nlookup: Tuple or single Dimension or dimension Type.\nf: <: by default, but can be >: to match abstract types to concrete types.\n\nCheck if an object or tuple contains an Dimension, or a tuple of dimensions.\n\nExample\n\njulia> using DimensionalData\n\njulia> A = DimArray(ones(10, 10, 10), (X, Y, Z));\n\n\njulia> hasdim(A, X)\ntrue\n\njulia> hasdim(A, (Z, X, Y))\n(true, true, true)\n\njulia> hasdim(A, Ti)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.hasselection","page":"API","title":"DimensionalData.hasselection","text":"hasselection(x, selector) => Bool\nhasselection(x, selectors::Tuple) => Bool\n\nCheck if indexing into x with selectors can be performed, where x is some object with a dims method, and selectors is a Selector or Dimension or a tuple of either.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.dimnum","page":"API","title":"DimensionalData.dimnum","text":"dimnum(x, lookup::Tuple) => NTuple{Int}\ndimnum(x, lookup) => Int\n\nGet the number(s) of Dimension(s) as ordered in the dimensions of an object.\n\nArguments\n\nx: any object with a dims method, a Tuple of Dimension or a single Dimension.\nlookup: Tuple, Array or single Dimension or dimension Type.\n\nThe return type will be a Tuple of Int or a single Int, depending on wether lookup is a Tuple or single Dimension.\n\nExample\n\njulia> using DimensionalData\n\njulia> A = DimArray(ones(10, 10, 10), (X, Y, Z));\n\n\njulia> dimnum(A, (Z, X, Y))\n(3, 1, 2)\n\njulia> dimnum(A, Y)\n2\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.otherdims","page":"API","title":"DimensionalData.otherdims","text":"otherdims(x, lookup) => Tuple{Vararg{<:Dimension,N}}\n\nGet the dimensions of an object not in lookup.\n\nArguments\n\nx: any object with a dims method, a Tuple of Dimension.\nlookup: Tuple or single Dimension or dimension Type.\nf: <: by default, but can be >: to match abstract types to concrete types.\n\nA tuple holding the unmatched dimensions is always returned.\n\nExample\n\njulia> using DimensionalData\n\njulia> A = DimArray(ones(10, 10, 10), (X, Y, Z));\n\n\njulia> otherdims(A, X)\nY, Z\n\njulia> otherdims(A, (Y, Z))\nX\n\njulia> otherdims(A, Ti)\nX, Y, Z\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.commondims","page":"API","title":"DimensionalData.commondims","text":"commondims([f], x, lookup) => Tuple{Vararg{<:Dimension}}\n\nThis is basically dims(x, lookup) where the order of the original is kept, unlike dims where the lookup tuple determines the order\n\nAlso unlike dims,commondims always returns a Tuple, no matter the input. No errors are thrown if dims are absent from either x or lookup.\n\nf is <: by default, but can be >: to sort abstract types by concrete types.\n\njulia> using DimensionalData\n\njulia> A = DimArray(ones(10, 10, 10), (X, Y, Z));\n\n\njulia> commondims(A, X)\nX\n\njulia> commondims(A, (X, Z))\nX, Z\n\njulia> commondims(A, Ti)\n()\n\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"And some utility methods for transforming DimensionalData objects:","category":"page"},{"location":"api/","page":"API","title":"API","text":"set\r\nrebuild\r\nmodify\r\ndimwise\r\ndimwise!\r\nreorder\r\nBase.fill\r\nBase.rand\r\nBase.zeros\r\nBase.ones\r\nBase.map\r\nBase.copy!\r\nBase.cat","category":"page"},{"location":"api/#DimensionalData.set","page":"API","title":"DimensionalData.set","text":"set(x, val)\n\nSet the field matching the supertypes of values in xs and return a new object.\n\nAs DimensionalData is so strongly typed you do not need to specify what field to set - there is no ambiguity.\n\nTo set fields of dimensions you need to specify the dimension. This can be done using Dimension => x pairs, X = x keyword arguments, Dimension wrapped arguments, or a NamedTuple.\n\nWhen dimensions or Lookups are passed to set to replace the existing ones, fields that are not set will keep their original values.\n\nNotes:\n\nChanging the dimension index range will set the Sampled lookup component Regular with a new step size, and set the dimension order.\n\nSetting Order will not reverse the array or dimension to match. Use reverse and reorder to do this.\n\nExamples\n\nda = DimArray(rand(3, 4), (Dim{:custom}(10.0:010.0:30.0), Z(-20:010.0:10.0)))\n\n# Set the array values\nset(da, zeros(3, 4))\n\n# Set the array name\nset(da, \"newname\") # Swap dimension type \n# Using Pairs \n# set(da, :Z => Ti, :custom => Z) \n# set(da, :custom => X, Z => Y)\n\n# Set the dimension index\n\n# To an `AbstractArray` set(da, Z => [:a, :b, :c, :d], :custom => [4, 5, 6])\n\n# To a `Val` tuple index (compile time indexing)\nset(da, Z(Val((:a, :b, :c, :d))), custom = 4:6)\n\n# Set dim lookups\nset(da, Z=NoLookup(), custom=Sampled())\nset(da, :custom => Irregular(10, 12), Z => Regular(9.9))\nset(da, (Z=NoLookup(), custom=Sampled()))\nset(da, custom=Reverse(), Z=Unordered())\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.rebuild","page":"API","title":"DimensionalData.rebuild","text":"rebuild(x, args...)\nrebuild(x; kw...)\n\nRebuild an object struct with updated field values.\n\nThis is an abstraction that alows inbuilt and custom types to be rebuilt functionally to update them, as most objects in DimensionalData.jl are immutable.\n\nThe arguments version can be concise but depends on a fixed order defined for some DimensionalData objects. It should be defined based on the object type in DimensionalData, adding the fields specific to your object.\n\nThe keyword version ignores order, and is mostly automated  using ConstructionBase.setproperties. It should only be defined if your object has  missing fields or fields with different names to DimensionalData objects.\n\nx can be a AbstractDimArray, a Dimension, Lookup or other custom types.\n\nThe arguments required are defined for the abstract type that has a rebuild method.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.modify","page":"API","title":"DimensionalData.modify","text":"modify(f, A::AbstractDimArray) => AbstractDimArray\nmodify(f, s::AbstractDimStack) => AbstractDimStack\nmodify(f, dim::Dimension) => Dimension\nmodify(f, x, lookupdim::Dimension) => typeof(x)\n\nModify the parent data, rebuilding the object wrapper without change. f must return a AbstractArray of the same size as the original.\n\nThis method is mostly useful as a way of swapping the parent array type of an object.\n\nExample\n\nIf we have a previously-defined DimArray, we can copy it to an Nvidia GPU with:\n\nA = DimArray(rand(100, 100), (X, Y))\nmodify(CuArray, A)\n\nThis also works for all the data layers in a DimStack.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.dimwise","page":"API","title":"DimensionalData.dimwise","text":"dimwise(f, A::AbstractDimArray{T,N}, B::AbstractDimArray{T2,M}) => AbstractDimArray{T3,N}\n\nDimension-wise application of function f to A and B.\n\nArguments\n\na: AbstractDimArray to broacast from, along dimensions not in b.\nb: AbstractDimArray to broadcast from all dimensions. Dimensions must be a subset of a.\n\nThis is like broadcasting over every slice of A if it is sliced by the dimensions of B.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.dimwise!","page":"API","title":"DimensionalData.dimwise!","text":"dimwise!(f, dest::AbstractDimArray{T1,N}, A::AbstractDimArray{T2,N}, B::AbstractDimArray) => dest\n\nDimension-wise application of function f.\n\nArguments\n\ndest: AbstractDimArray to update\nA: AbstractDimArray to broacast from, along dimensions not in b.\nB: AbstractDimArray to broadcast from all dimensions. Dimensions must be a subset of a.\n\nThis is like broadcasting over every slice of A if it is sliced by the dimensions of B, and storing the value in dest.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.reorder","page":"API","title":"DimensionalData.reorder","text":"reorder(A::AbstractDimArray, order::Pair) => AbstractDimArray\nreorder(A::Dimension, order::Order) => AbstractDimArray\n\nReorder every dims index/array to order, or reorder index for the the given dimension(s) to the Order they wrap.\n\norder can be an Order, or Dimeension => Order pairs.\n\nIf no axis reversal is required the same objects will be returned, without allocation.\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.fill","page":"API","title":"Base.fill","text":"Base.fill(x, dims::Dimension...) => DimArray\nBase.fill(x, dims::Tuple{Vararg{<:Dimension}}) => DimArray\n\nCreate a DimArray with a fill value of x.\n\nThere are two kinds of Dimension value acepted:\n\nA Dimension holding an AbstractVector will set the dimension index to  that AbstractVector, and detect the dimension lookup.\nA Dimension holding an Integer will set the length of the axis, and set the dimension lookup to NoLookup.\n\nExample\n\njulia> using DimensionalData\n\njulia> rand(Bool, X(2), Y(4))\n2×4 DimArray{Bool,2} with dimensions: X, Y\n 1  0  0  1\n 1  0  1  1\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.rand","page":"API","title":"Base.rand","text":"Base.rand(x, dims::Dimension...) => DimArray\nBase.rand(x, dims::Tuple{Vararg{<:Dimension}}) => DimArray\nBase.rand(r::AbstractRNG, x, dims::Tuple{Vararg{<:Dimension}}) => DimArray\nBase.rand(r::AbstractRNG, x, dims::Dimension...) => DimArray\n\nCreate a DimArray of random values.\n\nThere are two kinds of Dimension value acepted:\n\nA Dimension holding an AbstractVector will set the dimension index to  that AbstractVector, and detect the dimension lookup.\nA Dimension holding an Integer will set the length of the axis, and set the dimension lookup to NoLookup.\n\nExample\n\njulia> using DimensionalData\n\njulia> rand(Bool, X(2), Y(4))\n2×4 DimArray{Bool,2} with dimensions: X, Y\n 1  0  0  1\n 1  0  1  1\n\njulia> rand(X([:a, :b, :c]), Y(100.0:50:200.0))\n3×3 DimArray{Float64,2} with dimensions:\n  X: Symbol[a, b, c] Categorical: Unordered,\n  Y: 100.0:50.0:200.0 Sampled: Ordered Regular Points\n 0.43204   0.835111  0.624231\n 0.752868  0.471638  0.193652\n 0.484558  0.846559  0.455256\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.zeros","page":"API","title":"Base.zeros","text":"Base.zeros(x, dims::Dimension...) => DimArray\nBase.zeros(x, dims::Tuple{Vararg{Dimension}}) => DimArray\n\nCreate a DimArray of zeros.\n\nThere are two kinds of Dimension value acepted:\n\nA Dimension holding an AbstractVector will set the dimension index to  that AbstractVector, and detect the dimension lookup.\nA Dimension holding an Integer will set the length of the axis, and set the dimension lookup to NoLookup.\n\nExample\n\njulia> using DimensionalData\n\njulia> zeros(Bool, X(2), Y(4))\n2×4 DimArray{Bool,2} with dimensions: X, Y\n 0  0  0  0\n 0  0  0  0\n\njulia> zeros(X([:a, :b, :c]), Y(100.0:50:200.0))\n3×3 DimArray{Float64,2} with dimensions:\n  X: Symbol[a, b, c] Categorical: Unordered,\n  Y: 100.0:50.0:200.0 Sampled: Ordered Regular Points\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.ones","page":"API","title":"Base.ones","text":"Base.ones(x, dims::Dimension...) => DimArray\nBase.ones(x, dims::Tuple{Vararg{Dimension}}) => DimArray\n\nCreate a DimArray of ones.\n\nThere are two kinds of Dimension value acepted:\n\nA Dimension holding an AbstractVector will set the dimension index to  that AbstractVector, and detect the dimension lookup.\nA Dimension holding an Integer will set the length of the axis, and set the dimension lookup to NoLookup.\n\nExample\n\njulia> using DimensionalData\n\njulia> ones(Bool, X(2), Y(4))\n2×4 DimArray{Bool,2} with dimensions: X, Y\n 1  1  1  1\n 1  1  1  1\n\njulia> ones(X([:a, :b, :c]), Y(100.0:50:200.0))\n3×3 DimArray{Float64,2} with dimensions:\n  X: Symbol[a, b, c] Categorical: Unordered,\n  Y: 100.0:50.0:200.0 Sampled: Ordered Regular Points\n 1.0  1.0  1.0\n 1.0  1.0  1.0\n 1.0  1.0  1.0\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.map","page":"API","title":"Base.map","text":"Base.map(f, s::AbstractDimStack)\n\nApply functrion f to each layer of the stack s, and rebuild it.\n\nIf f returns DimArrays the result will be another DimStack. Other values will be returned in a NamedTuple.\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.copy!","page":"API","title":"Base.copy!","text":"Base.copy!(dst::AbstractArray, src::DiskGeoStack, key::Key)\n\nCopy the stack layer key to dst, which can be any AbstractArray.\n\nExample\n\nCopy the :humidity layer from stack to array.\n\ncopy!(array, stack, :humidity)\n\n\n\n\n\nBase.copy!(dst::AbstractDimStack, src::AbstractDimStack, [keys=keys(dst)])\n\nCopy all or a subset of layers from one stack to another.\n\nExample\n\nCopy just the :sea_surface_temp and :humidity layers from src to dst.\n\ncopy!(dst::AbstractDimStack, src::AbstractDimStack, keys=(:sea_surface_temp, :humidity))\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.cat","page":"API","title":"Base.cat","text":"Base.cat(stacks::AbstractGeoStack...; [keys=keys(stacks[1])], dims)\n\nConcatenate all or a subset of layers for all passed in stacks.\n\nKeywords\n\nkeys: Tuple of Symbol for the stack keys to concatenate.\ndims: Dimension of child array to concatenate on.\n\nExample\n\nConcatenate the :seasurfacetemp and :humidity layers in the time dimension:\n\ncat(stacks...; keys=(:sea_surface_temp, :humidity), dims=Ti)\n\n\n\n\n\n","category":"function"},{"location":"api/#Non-exported-methods-for-developers","page":"API","title":"Non-exported methods for developers","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"DimensionalData.dim2key\r\nDimensionalData.key2dim\r\nDimensionalData.dims2indices\r\nDimensionalData.selectindices\r\nDimensionalData.format\r\nDimensionalData.reducedims\r\nDimensionalData.swapdims\r\nDimensionalData.slicedims\r\nDimensionalData.comparedims\r\nDimensionalData.combinedims\r\nDimensionalData.sortdims\r\nDimensionalData.basetypeof\r\nDimensionalData.setdims\r\nDimensionalData.dimsmatch\r\nDimensionalData.dimstride\r\nDimensionalData.refdims_title\r\nDimensionalData.rebuild_from_arrays\r\nDimensionalData.shiftlocus","category":"page"},{"location":"api/#DimensionalData.dim2key","page":"API","title":"DimensionalData.dim2key","text":"dim2key(dim::Dimension) => Symbol\ndim2key(dims::Type{<:Dimension}) => Symbol\n\nConvert a dimension object to a simbol. X(), Y(), Ti() etc will be converted. to :X, :Y, :Ti, as with any other dims generated with the @dim macro.\n\nAll other Dim{S}() dimensions will generate Symbols S.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.key2dim","page":"API","title":"DimensionalData.key2dim","text":"key2dim(s::Symbol) => Dimension\nkey2dim(dims...) => Tuple{Dimension,Vararg}\nkey2dim(dims::Tuple) => Tuple{Dimension,Vararg}\n\nConvert a symbol to a dimension object. :X, :Y, :Ti etc will be converted. to X(), Y(), Ti(), as with any other dims generated with the @dim macro.\n\nAll other Symbols S will generate Dim{S}() dimensions.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.dims2indices","page":"API","title":"DimensionalData.dims2indices","text":"dims2indices(dim::Dimension, I) => NTuple{Union{Colon,AbstractArray,Int}}\n\nConvert a Dimension or Selector I to indices of Int, AbstractArray or Colon.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.selectindices","page":"API","title":"DimensionalData.selectindices","text":"selectindices(lookups, selectors)\n\nConverts Selector to regular indices.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.format","page":"API","title":"DimensionalData.format","text":"format(dims, x) => Tuple{Vararg{<:Dimension,N}}\n\nFormat the passed-in dimension(s) dims to match the object x.\n\nThis means converting indexes of Tuple to LinRange, and running format. Errors are also thrown if dims don't match the array dims or size.\n\nIf a Lookup hasn't been specified, an lookup is chosen based on the type and element type of the index:\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.reducedims","page":"API","title":"DimensionalData.reducedims","text":"reducedims(x, dimstoreduce) => Tuple{Vararg{<:Dimension}}\n\nReplace the specified dimensions with an index of length 1. This is usually to match a new array size where an axis has been reduced with a method like mean or reduce to a length of 1, but the number of dimensions has not changed.\n\nLookup traits are also updated to correspond to the change in cell step, sampling type and order.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.swapdims","page":"API","title":"DimensionalData.swapdims","text":"swapdims(x::T, newdims) => T\nswapdims(dims::Tuple, newdims) => Tuple{Vararg{<:Dimension}}\n\nSwap dimensions for the passed in dimensions, in the order passed.\n\nPassing in the Dimension types rewraps the dimension index, keeping the index values and metadata, while constructed Dimension objectes replace the original dimension. nothing leaves the original dimension as-is.\n\nArguments\n\nx: any object with a dims method or a Tuple of Dimension.\nnewdim: Tuple of Dimension or dimension Type.\n\nExample\n\nusing DimensionalData\nA = ones(X(2), Y(4), Z(2))\nswapdims(A, (Dim{:a}, Dim{:b}, Dim{:c}))\n# output\n2×4×2 DimArray{Float64,3} with dimensions: Dim{:a} NoLookup, Dim{:b} NoLookup, Dim{:c} NoLookup\n[:, :, 1]\n 1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0\n[and 1 more slices...]\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.slicedims","page":"API","title":"DimensionalData.slicedims","text":"slicedims(x, I) => Tuple{Tuple,Tuple}\nslicedims(f, x, I) => Tuple{Tuple,Tuple}\n\nSlice the dimensions to match the axis values of the new array.\n\nAll methods return a tuple conatining two tuples: the new dimensions, and the reference dimensions. The ref dimensions are no longer used in the new struct but are useful to give context to plots.\n\nCalled at the array level the returned tuple will also include the previous reference dims attached to the array.\n\nArguments\n\nf: a function getindex,  view or dotview. This will be used for slicing   getindex is the default if f is not included.\nx: An AbstractDimArray, Tuple of Dimension, or Dimension\nI: A tuple of Integer, Colon or AbstractArray\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.comparedims","page":"API","title":"DimensionalData.comparedims","text":"comparedims(A::AbstractDimArray...)\ncomparedims(A::Tuple...)\ncomparedims(a, b)\n\nCheck that dimensions or tuples of dimensions are the same, and return the first valid dimension. If AbstractDimArrays are passed as arguments their dimensions are compared.\n\nEmpty tuples and nothing dimension values are ignored, returning the Dimension value if it exists.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.combinedims","page":"API","title":"DimensionalData.combinedims","text":"combinedims(xs; check=true)\n\nCombine the dimensions of each object in xs, in the order they are found.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.sortdims","page":"API","title":"DimensionalData.sortdims","text":"sortdims([f], tosort, order) => Tuple\n\nSort dimensions tosort by order. Dimensions in order but missing from tosort are replaced with nothing.\n\ntosort and order can be Tuples or Vectors or Dimension or dimension type. Abstract supertypes like TimeDim can be used in order.\n\nf is <: by default, but can be >: to sort abstract types by concrete types.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.basetypeof","page":"API","title":"DimensionalData.basetypeof","text":"basetypeof(x) => Type\n\nGet the \"base\" type of an object - the minimum required to define the object without it's fields. By default this is the full UnionAll for the type. But custom basetypeof methods can be defined for types with free type parameters.\n\nIn DimensionalData this is primariliy used for comparing Dimensions, where Dim{:x} is different from Dim{:y}.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.setdims","page":"API","title":"DimensionalData.setdims","text":"setdims(X, newdims) => AbstractArray\nsetdims(::Tuple, newdims) => Tuple{Vararg{<:Dimension,N}}\n\nReplaces the first dim matching <: basetypeof(newdim) with newdim, and returns a new object or tuple with the dimension updated.\n\nArguments\n\nx: any object with a dims method, a Tuple of Dimension or a single Dimension.\nnewdim: Tuple or single Dimension, Type or Symbol.\n\nExample\n\nusing DimensionalData\nA = DimArray(ones(10, 10), (X, Y(10:10:100)))\nB = setdims(A, Y(Categorical('a':'j'; order=Ordered())))\nindex(B, Y)\n# output\nERROR: MethodError: no constructors have been defined for Ordered\nStacktrace:\n [1] top-level scope\n   @ none:1\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.dimsmatch","page":"API","title":"DimensionalData.dimsmatch","text":"dimsmatch([f], dim, lookup) => Bool\ndimsmatch([f], dims::Tuple, lookups::Tuple) => Bool\n\nCompare 2 dimensions or Tuple of Dimension are of the same base type, or are at least rotations/transformations of the same type.\n\nf is <: by default, but can be >: to match abstract types to concrete types.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.dimstride","page":"API","title":"DimensionalData.dimstride","text":"dimstride(x, dim) => Int\n\nGet the stride of the dimension relative to the other dimensions.\n\nThis may or may not be equal to the stride of the related array, although it will be for Array.\n\nArguments\n\nx is any object with a dims method, or a Tuple of Dimension.\ndim is a Dimension, Dimension type, or and Int. Using an Int is not type-stable.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.refdims_title","page":"API","title":"DimensionalData.refdims_title","text":"refdims_title(A::AbstractDimArray)\nrefdims_title(refdims::Tuple)\nrefdims_title(refdim::Dimension)\n\nGenerate a title string based on reference dimension values.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.rebuild_from_arrays","page":"API","title":"DimensionalData.rebuild_from_arrays","text":"rebuild_from_arrays(s::AbstractDimStack, das::NamedTuple{<:Any,<:Tuple{Vararg{<:AbstractDimArray}}}; kw...)\n\nRebuild an AbstractDimStack from a NamedTuple of AbstractDimArray and an existing stack.\n\nKeywords\n\nKeywords are simply the fields of the stack object:\n\ndata\ndims\nrefdims\nmetadata\nlayerdims\nlayermetadata\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.shiftlocus","page":"API","title":"DimensionalData.shiftlocus","text":"shiftlocus(locus::Locus, x)\n\nShift the index of x from the current locus to the new locus.\n\nWe only shift Samped, Regular or Explicit, Intervals. \n\n\n\n\n\n","category":"function"},{"location":"developer/#For-package-developers","page":"For Developers","title":"For package developers","text":"","category":"section"},{"location":"developer/#Goals:","page":"For Developers","title":"Goals:","text":"","category":"section"},{"location":"developer/","page":"For Developers","title":"For Developers","text":"Maximum extensibility: always use method dispatch. Regular types over special syntax. Recursion over @generated.\nFlexibility: dims and selectors are parametric types with multiple uses\nAbstraction: never dispatch on concrete types, maximum re-usability of methods\nClean, readable syntax. Minimise required parentheses, minimise of exported methods, and instead extend Base methods whenever possible.\nMinimal interface: implementing a dimension-aware type should be easy.\nFunctional style: structs are always rebuilt, and other than the array data, fields are not mutated in place.\nLaziness. Label data correctly, and manipulate them when needed -  instead of standardising eagerly.\nLeast surprise: everything works the same as in Base, but with named dims. If a method accepts numeric indices or dims=X in base, you should be able to use DimensionalData.jl dims.\nType stability: dimensional methods should be type stable more often than Base methods\nZero cost dimensional indexing a[Y(4), X(5)] of a single value.\nLow cost indexing for range getindex and views: these cant be zero cost as dim ranges have to be updated.\nPlotting is easy: data should plot sensibly and correctly with useful labels - after all transformations using dims or indices\nPrioritise spatial data: other use cases are a free bonus of the modular approach.","category":"page"},{"location":"developer/#Why-this-package","page":"For Developers","title":"Why this package","text":"","category":"section"},{"location":"developer/","page":"For Developers","title":"For Developers","text":"Why not AxisArrays.jl or NamedDims.jl?","category":"page"},{"location":"developer/#Structure","page":"For Developers","title":"Structure","text":"","category":"section"},{"location":"developer/","page":"For Developers","title":"For Developers","text":"Both AxisArrays and NamedDims use concrete types for dispatch on arrays, and for dimension type Axis in AxisArrays. This makes them hard to extend.","category":"page"},{"location":"developer/","page":"For Developers","title":"For Developers","text":"Its a little easier with DimensionalData.jl. You can inherit from AbstractDimArray, or just implement dims and rebuild methods. Dims and selectors in DimensionalData.jl are also extensible. Recursive primitive methods allow inserting whatever methods you want to add extra types. @generated is only used to match and permute arbitrary tuples of types, and contain no type-specific details. The @generated functions in AxisArrays internalise axis/index conversion behaviour preventing extension in external packages and scripts.","category":"page"},{"location":"developer/#Syntax","page":"For Developers","title":"Syntax","text":"","category":"section"},{"location":"developer/","page":"For Developers","title":"For Developers","text":"AxisArrays.jl is verbose by default: a[Axis{:y}(1)] vs a[Y(1)] used here. NamedDims.jl has concise syntax, but the dimensions are no longer types, NamedDims.jl syntax can now be replicated using Dim{:X}: ","category":"page"},{"location":"developer/","page":"For Developers","title":"For Developers","text":"A = Dimarray(rand(4, 5), (:a, :b)\r\nA[:b=5, :a=3] = 25.0","category":"page"},{"location":"developer/#Data-types-and-the-interface","page":"For Developers","title":"Data types and the interface","text":"","category":"section"},{"location":"developer/","page":"For Developers","title":"For Developers","text":"DimensionalData.jl provides the concrete DimArray type. But it's core purpose is to be easily used with other array types.","category":"page"},{"location":"developer/","page":"For Developers","title":"For Developers","text":"Some of the functionality in DimensionalData.jl will work without inheriting from AbstractDimArray. The main requirement define a dims method that returns a Tuple of Dimension that matches the dimension order and axis values of your data. Define rebuild, and base methods for similar and parent if you want the metadata to persist through transformations (see the DimArray and AbstractDimArray types). A refdims method returns the lost dimensions of a previous transformation, passed in to the rebuild method. refdims can be discarded, the main loss being plot labels.","category":"page"},{"location":"developer/","page":"For Developers","title":"For Developers","text":"Inheriting from AbstractDimArray will give nearly all the functionality of using DimArray.","category":"page"},{"location":"course/#Crash-course","page":"Crash course","title":"Crash course","text":"","category":"section"},{"location":"course/","page":"Crash course","title":"Crash course","text":"This is brief a tutorial for DimensionalData.jl.","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"The main functionality is explained here, but the full list of features is listed at the API page.","category":"page"},{"location":"course/#Dimensions-and-DimArrays","page":"Crash course","title":"Dimensions and DimArrays","text":"","category":"section"},{"location":"course/","page":"Crash course","title":"Crash course","text":"The core type of DimensionalData.jl is the Dimension and the types that inherit from it, such as Ti, X, Y, Z, the generic Dim{:x}, or others that you define manually using the @dim macro.","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"Dimensions are primarily used in DimArray, other AbstractDimArray.","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"We can use dimensions without a value index - these simply label the axis. A DimArray with labelled dimensions is constructed by:","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"using DimensionalData\r\nA = rand(X(5), Y(5))\r\nA[Y(1), X(2)]","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"Or we can use the Dim{X} dim by using Symbols:","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"A = DimArray(rand(5, 5), (:a, :b))\r\nA[a=3, b=5]","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"But often, we want to provide a lookup index for the dimension:","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"using Dates\r\nt = DateTime(2001):Month(1):DateTime(2001,12)\r\nx = 10:10:100\r\nA = DimArray(rand(12, 10), (Ti(t), X(x)))","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"Here both X and Ti are dimensions from DimensionalData. The currently exported dimensions are X, Y, Z, Ti. Ti is shortening of Time - to avoid the conflict with Dates.Time.","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"The length of each dimension index has to match the size of the corresponding array axis. ","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"This can also be done with Symbol, using Dim{X}:","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"A2 = DimArray(rand(12, 10), (time=t, distance=x))","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"Symbols can be more convenient than defining dims with @dim, but have some downsides. They don't inherit from a specific Dimension type, so plots will not know what axis to put them on. If you need to specify the dimension mode or metadata manually, the Dim{X} syntax becomes less beneficial. ","category":"page"},{"location":"course/#Indexing-the-array-by-name-and-index","page":"Crash course","title":"Indexing the array by name and index","text":"","category":"section"},{"location":"course/","page":"Crash course","title":"Crash course","text":"Dimensions can be used to index the array by name, without having to worry about the order of the dimensions.","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"The simplest case is to select a dimension by index. Let's say every 2nd point of the Ti dimension and every 3rd point of the X dimension. This is done with the simple Ti(range) syntax like so:","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"A[X(1:3:11), Ti(1:2:11)]","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"Of course, when specifying only one dimension, all elements of the other dimensions are assumed to be included:","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"A[X(1:3:10)]","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"info: Indexing\nIndexing AbstractDimArrays works with getindex, setindex! and view. The result is still an AbstracDimArray.","category":"page"},{"location":"course/#Selecting-by-name-and-value","page":"Crash course","title":"Selecting by name and value","text":"","category":"section"},{"location":"course/","page":"Crash course","title":"Crash course","text":"The above example is useful because one does not have to care about the ordering of the dimensions. But arguably more useful is to be able to select a dimension by its values. For example, we would like to get all values of A where the X dimension is between two values.","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"Selecting by value in DimensionalData is done with the selectors, which are listed in the Selectors page. This avoids the ambiguity of what happens when the index values of the dimension are also integers (like the case here for the dimension X).","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"For simplicity, here we use the Between selector, but  others also exist, like At, Contains, or Near.","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"A[X(Between(12, 35)), Ti(Between(Date(2001, 5), Date(2001, 7)))]","category":"page"},{"location":"course/#Selecting-by-position","page":"Crash course","title":"Selecting by position","text":"","category":"section"},{"location":"course/","page":"Crash course","title":"Crash course","text":"So far, the selection protocols we have mentioned work by specifying the name of the dimension, without worry about the order.","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"However normal indexing also works by specifying dimensions by position. This functionality also covers Selectors.","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"Continuing to use A we defined above, you can see how this works by comparing the statements without and with names:","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"A[:, Between(12, 35)] == A[X(Between(12, 35))]\r\nA[:, 1:5] == A[X(1:5)]\r\nA[1:5, :] == A[Ti(1:5)]","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"Using this approach it is necessary to specify all dimensions by position. ","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"In addition, to support as base Julia functionality single index access like in standard Array:","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"A[1:5]","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"This selects the first 5 entries of the underlying array. In the case that A has only one dimension, it will be retained. Multidimensional AbstracDimArray indexed this way will return a regular array.","category":"page"},{"location":"course/#Specifying-dims-keyword-arguments-with-Dimension","page":"Crash course","title":"Specifying dims keyword arguments with Dimension","text":"","category":"section"},{"location":"course/","page":"Crash course","title":"Crash course","text":"In many Julia functions like size or sum, you can specify the dimension along which to perform the operation as an Int. It is also possible to do this using Dimension types with AbstractDimArray:","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"sum(A; dims=X)","category":"page"},{"location":"course/#Numeric-operations-on-dimension-arrays-and-dimensions","page":"Crash course","title":"Numeric operations on dimension arrays and dimensions","text":"","category":"section"},{"location":"course/","page":"Crash course","title":"Crash course","text":"Numeric operations on a AbstractDimArray match base Julia as much as possible. Standard broadcasting and other type of operations across dimensional arrays typically perform as expected while still returning an AbstractDimArray type with correct dimensions.","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"In cases where you would like to do some operation on the dimension index, e.g. take the cosines of the values of the dimension X while still keeping the dimensional information of X, you can use the syntax:","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"DimArray(cos, dims(A, X))","category":"page"},{"location":"course/#Referenced-dimensions","page":"Crash course","title":"Referenced dimensions","text":"","category":"section"},{"location":"course/","page":"Crash course","title":"Crash course","text":"The reference dimensions record the previous dimensions that an array was selected from. These can be use for plot labelling, and tracking array changes.","category":"page"},{"location":"course/#Lookups","page":"Crash course","title":"Lookups","text":"","category":"section"},{"location":"course/","page":"Crash course","title":"Crash course","text":"DimensionalData provides types for specifying details about the dimension index. This enables optimisations with Selectors, and modified behaviours such as selection of intervals or points, which will give slightly different results for selectors like Between for Points and Intervals.","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"This also allows reverse order index to still work with seartsorted, and for plots to always be the right way up when either the index or the  array is backwards - reversing the data lazily when required, not when loaded.","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"The major categories of Lookup are Categorical, Sampled and NoLookup, which are all subtypes of Aligned. Unaligned also exists to handle dimensions with an index that is rotated or otherwise transformed in relation to the underlying array, such as Transformed.","category":"page"},{"location":"course/#Lookup-detection","page":"Crash course","title":"Lookup detection","text":"","category":"section"},{"location":"course/","page":"Crash course","title":"Crash course","text":"Aligned types will be detected automatically if not specified - mostly specifying them isn't required. A Dimension containing and index of String, Char or Symbol will be given the Categorical mode. A range will be Sampled, defaulting to Points and Regular, with the Order detected automatically. ","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"See the api docs for specifics about these Lookups.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"DimensionalData","category":"page"},{"location":"#DimensionalData","page":"Introduction","title":"DimensionalData","text":"DimensionalData\n\n(Image: ) (Image: ) (Image: CI) (Image: Codecov) (Image: Aqua.jl Quality Assurance)\n\nDimensionalData.jl provides tools and abstractions for working with datasets that have named dimensions, and optionally a lookup index. It's a pluggable,  generalised version of AxisArrays.jl  with a cleaner syntax, and additional functionality found in NamedDims.jl. It has  similar goals to pythons xarray, and is primarily written for use with spatial data in GeoData.jl.\n\nBroadcasting and most Base methods maintain and sync dimension context.\n\nDimensionalData.jl also implements:\n\ncomprehensive plot recipes for Plots.jl.\na Tables.jl interface with DimTable\nmulti-layered DimStacks that can be indexed together,    and have base methods applied to all layers.\nthe Adapt.jl interface for use on GPUs, even as GPU kernel arguments.\ntraits for handling a wide range of spatial data types accurately.\n\nDimensions\n\nDimensions are wrapper types. They hold the lookup index, details about the  grid, and other metadata. They are also used to index into the array.  X, Y, Z and Ti are the exported defaults. A generalised Dim type is available  to use arbitrary symbols to name dimensions. Custom dimension types can also be defined  using the @dim macro.\n\nDimensions can be used to construct arrays in rand, ones, zeros and fill with  either a range for a lookup index or a number for the dimension length:\n\njulia> using DimensionalData\n\njulia> A = rand(X(1:40), Y(50))\n40×50 DimArray{Float64,2} with dimensions:\n  X: 1:40 (Sampled - Ordered Regular Points)\n  Y\n 0.929006   0.116946  0.750017  …  0.172604  0.678835   0.495294\n 0.0550038  0.100739  0.427026     0.778067  0.309657   0.831754\n ⋮                              ⋱\n 0.647768   0.965682  0.049315     0.220338  0.0326206  0.36705\n 0.851769   0.164914  0.555637     0.771508  0.964596   0.30265\n\nWe can also use dim wrappers for indexing, so that the dimension order in the underlying array does not need to be known:\n\njulia> A[Y(1), X(1:10)]\n10-element DimArray{Float64,1} with dimensions:\n  X: 1:10 (Sampled - Ordered Regular Points)\nand reference dimensions: Y(1) \n 0.929006\n 0.0550038\n 0.641773\n ⋮\n 0.846251\n 0.506362\n 0.0492866\n\nAnd this has no runtime cost:\n\njulia> A = ones(X(3), Y(3))\n3×3 DimArray{Float64,2} with dimensions: X, Y\n 1.0  1.0  1.0\n 1.0  1.0  1.0\n 1.0  1.0  1.0\n\njulia> @btime $A[X(1), Y(2)]\n  1.077 ns (0 allocations: 0 bytes)\n1.0\n\njulia> @btime parent($A)[1, 2]\n  1.078 ns (0 allocations: 0 bytes)\n1.0\n\nDims can be used in X=val form:\n\njulia> A = rand(X(40), Y(50))\n40×50 DimArray{Float64,2} with dimensions: X, Y\n 0.377696  0.105445  0.543156  …  0.844973  0.163758  0.849367\n ⋮                             ⋱\n 0.431454  0.108927  0.137541     0.531587  0.592512  0.598927\n\njulia> A[Y=3]\n40-element DimArray{Float64,1} with dimensions: X\nand reference dimensions: Y(3)\n 0.543156\n ⋮\n 0.137541\n\nFor views:\n\njulia> view(A, Y(), X(1:5))\n5×50 DimArray{Float64,2} with dimensions: X, Y\n 0.377696  0.105445  0.543156  …  0.844973  0.163758  0.849367\n ⋮                             ⋱\n 0.875279  0.133032  0.925045     0.156768  0.736917  0.444683\n\nAnd for specifying dimension number in all Base and Statistics  functions that have a dims argument:\n\njulia> using Statistics\n\njulia> A = rand(X(3), Y(4), Ti(5));\n\njulia> mean(A; dims=Ti)\n3×4×1 DimArray{Float64,3} with dimensions: X, Y, Ti (Time)\n[:, :, 1]\n 0.168058  0.52353   0.563065  0.347025\n 0.472786  0.395884  0.307846  0.518926\n 0.365028  0.381367  0.423553  0.369339\n\nYou can also use symbols to create Dim{X} dimensions. We can't use the rand method directly with Symbols, so insteadd use the regular DimArray constructor:\n\njulia> A = DimArray(rand(10, 20, 30), (:a, :b, :c));\n\njulia> A[a=2:5, c=9]\n\n4×20 DimArray{Float64,2} with dimensions: Dim{:a}, Dim{:b}\nand reference dimensions: Dim{:c}(9)\n 0.134354  0.581673  0.422615  …  0.410222   0.687915  0.753441\n 0.573664  0.547341  0.835962     0.0353398  0.794341  0.490831\n 0.166643  0.133217  0.879084     0.695685   0.956644  0.698638\n 0.325034  0.147461  0.149673     0.560843   0.889962  0.75733\n\nSelectors\n\nSelectors find indices in the lookup index, for each dimension: \n\nAt(x): get the index exactly matching the passed in value(s)\nNear(x): get the closest index to the passed in value(s)\nWhere(f::Function): filter the array axis by a function of the    dimension index values.\nBetween(a, b): get all indices between two values, excluding the high value.\nContains(x): get indices where the value x falls within the interval, exluding    the upper value. Only used for Sampled Intervals, for Points, use At.\n\n(Between and Contains exlude the upper boundary so that adjacent selections never contain the same index)\n\nSelectors can be used in getindex, setindex! and view to select indices matching the passed in value(s)\n\nWe can use selectors inside dim wrappers:\n\njulia> using Dates\n\njulia> timespan = DateTime(2001,1):Month(1):DateTime(2001,12)\nDateTime(\"2001-01-01T00:00:00\"):Month(1):DateTime(\"2001-12-01T00:00:00\")\n\njulia> A = DimArray(rand(12,10), (Ti(timespan), X(10:10:100)))\n12×10 DimArray{Float64,2} with dimensions:\n  Ti (Time): DateTime(\"2001-01-01T00:00:00\"):Month(1):DateTime(\"2001-12-01T00:00:00\") (Sampled - Ordered Regular Points)\n  X: 10:10:100 (Sampled - Ordered Regular Points)\n 0.14106   0.476176  0.311356  0.454908  …  0.464364  0.973193  0.535004\n ⋮                                       ⋱\n 0.522759  0.390414  0.797637  0.686718     0.901123  0.704603  0.0740788\n\njulia> @btime A[X(Near(35)), Ti(At(DateTime(2001,5)))]\n0.3133109280208961\n\nWithout dim wrappers selectors must be in the right order:\n\nusing Unitful\n\njulia> A = rand(X((1:10:100)u\"m\"), Ti((1:5:100)u\"s\"));\n\njulia> A[Between(10.5u\"m\", 50.5u\"m\"), Near(23u\"s\")]\n4-element DimArray{Float64,1} with dimensions:\n  X: (11:10:41) m (Sampled - Ordered Regular Points)\nand reference dimensions:\n  Ti(21 s) (Time): 21 s (Sampled - Ordered Regular Points)\n 0.584028\n ⋮\n 0.716715\n\nMethods where dims can be used containing indices or Selectors\n\ngetindex, setindex! view\n\nMethods where dims, dim types, or Symbols can be used to indicate the array dimension:\n\nsize, axes, firstindex, lastindex\ncat, reverse, dropdims\nreduce, mapreduce\nsum, prod, maximum, minimum,\nmean, median, extrema, std, var, cor, cov\npermutedims, adjoint, transpose, Transpose\nmapslices, eachslice\n\nMethods where dims can be used to construct DimArrays:\n\nfill, ones, zeros, rand\n\nWarnings\n\nIndexing with unordered or reverse order arrays has undefined behaviour. It will trash the dimension index, break searchsorted and nothing will make sense any more. So do it at you own risk. However, indexing with sorted vectors of Int can be useful. So it's allowed. But it will still do strange things to your interval sizes if the dimension span is Irregular.\n\nAlternate Packages\n\nThere are a lot of similar Julia packages in this space. AxisArrays.jl, NamedDims.jl, NamedArrays.jl are registered alternative that each cover some of the functionality provided by DimensionalData.jl. DimensionalData.jl should be able to replicate most of their syntax and functionality.\n\nAxisKeys.jl and AbstractIndices.jl are some other interesting developments. For more detail on why there are so many similar options and where things are headed, read this thread.\n\n\n\n\n\n","category":"module"},{"location":"","page":"Introduction","title":"Introduction","text":"To learn how to use this package, see the Crash course.","category":"page"}]
}
